<script src="https://cdn.jsdelivr.net/gh/orstavik/ElementObserver@1.1.2/observeElementCreation.js"></script>
<script src="../../src/customAttributes.js"></script>
<script src="../../src/core.js"></script>
<script src="../../src/GestureAttr.js"></script>

<style>
  div {
    position: absolute;
    width: 20vh;
    height: 32vh;
    margin: 10vh calc(50% - 10vh);
  }

  .right {
    transition: all 0.8s;
    transform: rotate(15deg);
    margin-left: 100vw;
  }

  .left {
    transition: all 0.8s;
    transform: rotate(-15deg);
    margin-left: -20vh;
  }
</style>

<body swipe:swipe-longer-than_100:replace>
<div
    swipeable_100
    swipe:swipe-longer-than_100:left-right:await2_800:this.owner-element.remove
    ready:random-color:this.owner-element.style.background-color_e
></div>
</body>

<script>
  //todo these should be moved into the core.js lib. The await2 is also used in the GestureAttr.
  customReactions.define("prevent", e => (e.preventDefault(), e));
  customReactions.define("await2", async (e, prefix, num) => {
    if (num && isNaN(num))
      throw new SyntaxError(`${prefix}_${num} is illegal, the _${num} is not a number.`);
    await (num ? new Promise(r => setTimeout(r, num)) : Promise.resolve());
    return e;
  });

  //todo 1 swipeable should have the _100 argument.
  //todo 2 swipeable should store the position of the starting entry as value. event caching.
  //todo 3 if/else logic. should we use a once-reaction? or should we do something prolog style?

  //todo but here we need a SwipeEvent extends MouseEvent that has getters for custom direction, and an extra point for the value of the x,y.
  //todo the copyEvent should also be standardized. It is something that we can
  function copyEvent(e, prefix) {
    return new e.constructor(prefix, e);
  }

  function dispatch(e){
    eventLoop.dispatch(e, this.ownerElement);
    return e;
  }

  customReactions.define("dispatch", dispatch);

  customReactions.define("swipe", copyEvent);
  customReactions.define("swipe-start", copyEvent);
  customReactions.define("swipe-cancel", copyEvent);

  let swipeStart = 0;

  customAttributes.define("swipeable", class SwipeAttr extends GestureAttr {
    static stateMachine(length = 50) {
      return {
        "": [["mousedown:swipestart:swipe-start:dispatch", "start"]],
        start: [
          //todo add the start x,y, and have the swipe be a different class of event.
          [`_mouseup::swipe:dispatch`, ""],
          //todo the problem is what should we do with _mouseup when the filter fails?
          [`_mouseup:swipe-cancel:dispatch`, ""],
          ["_blur:swipe-cancel:dispatch", ""],
          ["_selectstart:prevent", ""]
        ]
      };
    }
  });

  customReactions.define("swipestart", e => ((swipeStart = e.x), e));

  customReactions.define("random-color", function randomColor() {
    return 'rgb(' + (Math.floor(Math.random() * 256)) + ',' + (Math.floor(Math.random() * 256)) + ',' + (Math.floor(Math.random() * 256)) + ')';
  });

  customReactions.define("replace", function replaceElement() {
    this.ownerElement.insertAdjacentHTML("afterbegin",
`<div
    swipeable_100
    swipe:swipe-longer-than_100:left-right:await2_800:this.owner-element.remove
    ready:random-color:this.owner-element.style.background-color_e
></div>`);
  });

  //todo :gte_e.length_100 //todo does the dot expression manage to utilize the defined reactions?
  customReactions.define("swipe-longer-than", function (e, _, length) {
    const swipeDist = swipeStart - e.x;
    if (Math.abs(swipeDist) >= length)
      return swipeDist;
  });
  customReactions.define("left-right", function (e) {
    this.ownerElement.classList.add(e > 0 ? "left" : "right");
    return e;
  });
</script>